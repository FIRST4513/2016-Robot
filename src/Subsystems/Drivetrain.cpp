// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Drivetrain.h"
#include "../RobotMap.h"
#include "../Commands/DriveByJoystickArcade.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMtr = RobotMap::drivetrainLeftMtr;
    rightMtr = RobotMap::drivetrainRightMtr;
    robotDrive2 = RobotMap::drivetrainRobotDrive2;
    driveLeftEncoder = RobotMap::drivetrainDriveLeftEncoder;
    driveRightEncoder = RobotMap::drivetrainDriveRightEncoder;
    gyroA = RobotMap::drivetrainGyroA;
    maxSonar = RobotMap::drivetrainMaxSonar;
    proxSensor = RobotMap::drivetrainProxSensor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());

	SetDefaultCommand(new ::DriveByJoystickArcade);

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

	gyroLastHdg = gyroA->GetAngle();
	currEncLft=0, beginEncLft=0, endEncLft=0;
	currEncRt=0, beginEncRt=0, endEncRt=0;
	currHdg=0, beginHdg=0, endHdg=0;
	robotDrive2->SetSafetyEnabled(false);
}


// Put methods for controlling this subsystem
// here. Call these from Commands.


// ------------------------- Robot Drive -------------------------------
void Drivetrain::Drive(float speed, float turn){
	if(firstTimeFlag==0){
		gyroLastHdg=GetHeading(0);
		firstTimeFlag=1;
	}
	CalculateCorrection();

	robotDrive2->Drive(speed, correction);
}

// ------------------------- Tank Drive -------------------------------
void Drivetrain::TankDrive(double leftSpeed, double rightSpeed){
	robotDrive2->TankDrive((float)leftSpeed, (float)rightSpeed);
}

// ------------------------- Stop Robot -------------------------------
void Drivetrain::Stop(){
	robotDrive2->TankDrive(0.0,0.0);
}


// -------------------------- Drive By Joy Stick -------------------------------
void Drivetrain::DriveByJoystickArcade(std::shared_ptr<Joystick> joy){
		throttle=joy->GetThrottle();								// put throttle value into variable Throttle
		throttle=((throttle-1)/-2);									// converts range to 0 to +1

		yValue=joy->GetY();											// sets y value of joystick to variable YValue
		if(((yValue) <= (XYDEADBAND * throttle)) &&
		   ((yValue) >= - (XYDEADBAND * throttle)))
				yValue=0;											// if YValue is within the deadband, don't move
		else
				yValue=yValue*throttle;

		twistValue=joy->GetTwist();									// sets twist value of joystick to variable TwistValue
		if((twistValue <= (TWISTDEADBAND * throttle)) &&
		   (twistValue >= - (TWISTDEADBAND * throttle)))
				twistValue=0;			// if YValue is within the deadband, don't move
		else
				twistValue=((twistValue*throttle)/TWISTTHROTTLEMOD);// changing TwistValue based on Throttle value

		robotDrive2->ArcadeDrive((yValue*-1),(twistValue*-1));		// runs function/method for the ArcadeDrive
}


void Drivetrain::ShooterDriveByJoystickArcade(std::shared_ptr<Joystick> joy){
	 	int topPOV = joy->GetPOV();

	 	throttle=joy->GetThrottle();								// put throttle value into variable Throttle
		throttle=((throttle-1)/-2);									// converts range to 0 to +1

		twistValue=joy->GetTwist();									// sets twist value of joystick to variable TwistValue
		if(((twistValue) <= (TWISTDEADBAND * throttle)) &&
		   ((twistValue) >= -(TWISTDEADBAND * throttle)))
				twistValue=0;										// if YValue is within the deadband, don't move
		else
			twistValue=(((twistValue*throttle)/(TWISTTHROTTLEMOD*1.25)));// changing TwistValue based on Throttle value

		yValue = 0;													// Assume no Top button pressed
		if (topPOV == 0) yValue = SHOOTERTOPSWSPEED * -1;			// top forward button pressed
		if (topPOV == 180) yValue = SHOOTERTOPSWSPEED;				// Reverse button pressed

		robotDrive2->ArcadeDrive((yValue*-1),(twistValue*-1));		//runs function/method for the ArcadeDrive
}



// ------------------------ AutoAim Methods -----------------------

void Drivetrain::PutShooterAutoAimFlag(bool flag){
	shooterAutoAimFlag = flag;
}

bool Drivetrain::GetAutoAimFlag(){
	return shooterAutoAimFlag;
}

void Drivetrain::PutShooterAutoAimHdg(float hdg){
	shooterAutoAimHdg = hdg;
}

float Drivetrain::GetShooterAutoAimHdg(){
	return shooterAutoAimHdg;
}

// --------------------------- Get Distance Info -------------------------
float  Drivetrain::GetSonarValue(){
	return maxSonar->GetAverageVoltage();
}

float Drivetrain::GetDistanceBySonar(){
	 return (((maxSonar->GetAverageVoltage() / 0.0048828) * 0.19685) + 1);	// 0.19685 = inch per 5mm, 0.0048828 = 5 volts / 1024
}

float  Drivetrain::GetProxValue(){
	return proxSensor->GetAverageVoltage();
}

float Drivetrain::GetDistanceByProx(){
	float x = proxSensor->GetAverageVoltage();
	return ((29.822 * (x * x)) - (115.44 * x) + 117.06);
}


// -------------------------- Gyro Routines ----------------------------
void Drivetrain::GyroInit(){
	// gyroA->SetDeadband(0.025);					// may need to play with this value
	gyroA->SetDeadband( 0.015);						// may need to play with this value
	gyroA->SetSensitivity(0.007);
}

void Drivetrain::GyroReset(){
	 gyroA->Reset();
}

float Drivetrain::GetHeadingByGyro(){
	 return  gyroA->GetAngle();
}

float Drivetrain::GetHeading(int method){			// Some thoughts of other methods IE) encoder for heading
	return  GetHeadingByGyro();
}



// ------------------- Set Flag for Gyro Correction Methods ------------------------
void Drivetrain::SetFirstTimeFlag(int val){
	firstTimeFlag = val;
}

// ----------------- Calculate Correction ----------------------------------------
void Drivetrain::CalculateCorrection(){
	gyroHdg = gyroA->GetAngle();
	origCorrection = ( - (gyroHdg-gyroLastHdg) * kGyroCorrectionConstant);
	correction = origCorrection;
	if (correction < 0){
		if (correction < kGyroCorrectionLwrLimit)  correction = kGyroCorrectionLwrLimit;
	}
	else
	{
		if (correction > kGyroCorrectionUpperLimit)  correction = kGyroCorrectionUpperLimit;
	}
//	printf("LastHd, %4.5f , CurrHd, %4.5f , Diff, %4.5f , Correction, %4.5f , Adj.Corr: %4.5f \n",
//			            gyroLastHdg, gyroHdg, gyroHdg-gyroLastHdg, origCorrection, correction);

}


// ------------------------- Encoder Routines ------------------------------------
double Drivetrain::GetLeftEncoder(){
	return driveLeftEncoder->GetRaw();
}

double Drivetrain::GetRightEncoder(){
	return driveRightEncoder->GetRaw();
}

void Drivetrain::ResetEncoders(){
	driveLeftEncoder->Reset();
	driveRightEncoder->Reset();
}

// ------------------ Get Distance Traveled Fwd ---------------------
double Drivetrain::GetDistance() {
	float dist;
	dist = (((driveRightEncoder->GetRaw() - driveLeftEncoder->GetRaw())/2) *kEncoderConv);
//	SmartDashboard::PutNumber("GetDistace=", dist);
	return dist;
}


// ------------------- Misc Methods ------------------------
void Drivetrain::ZeroBeginEndValues(){
	beginEncLft = 0;
	beginEncRt = 0;
	endEncRt = 0;
	endEncRt = 0;
	beginHdg = 0;
	endHdg = 0;
}


void Drivetrain::PostBeginValues(){
	beginEncLft = driveLeftEncoder->GetRaw();
	beginEncRt = driveRightEncoder->GetRaw();
	beginHdg = gyroA->GetAngle();
}

void Drivetrain::PostEndValues(){
	endEncLft = driveLeftEncoder->GetRaw();
	endEncRt = driveRightEncoder->GetRaw();
	endHdg = gyroA->GetAngle();
}

void Drivetrain::PostCurrValues(){
	currEncLft = driveLeftEncoder->GetRaw();
	currEncRt = driveRightEncoder->GetRaw();
	currHdg = gyroA->GetAngle();
}

void Drivetrain::DisplaySmartdashValues(){
	DisplaySmartdashSimple();

//	SmartDashboard::PutNumber("Begin Left Enc", beginEncLft);
//	SmartDashboard::PutNumber("Begin Right Enc", beginEncRt);
//	SmartDashboard::PutNumber("Begin Hdg", beginHdg);

//	SmartDashboard::PutNumber("End Left Enc", endEncLft);
//	SmartDashboard::PutNumber("End Right Enc", endEncRt);
//	SmartDashboard::PutNumber("End Hdg", endHdg);
}

void Drivetrain::DisplaySmartdashSimple(){
//	SmartDashboard::PutNumber("Curr Left Enc", GetLeftEncoder());
//	SmartDashboard::PutNumber("Curr Right Enc", GetRightEncoder());
	SmartDashboard::PutNumber("Curr Hdg", GetHeadingByGyro());
//	SmartDashboard::PutNumber("Sonar Dist", GetDistanceBySonar());
	SmartDashboard::PutNumber("Prox Dist", GetDistanceByProx());
	SmartDashboard::PutNumber("Prox Volt",proxSensor->GetAverageVoltage());

}
