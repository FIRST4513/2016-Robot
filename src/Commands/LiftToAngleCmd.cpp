// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "LiftToAngleCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

LiftToAngleCmd::LiftToAngleCmd(double angle, int mode): Command() {
    m_angle = angle;
    m_mode = mode;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::liftSys.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void LiftToAngleCmd::Initialize() {
	SetTimeout(10);								// we should get anywhere within 10 seconds
	netTable = NetworkTable::GetTable("MyVisionData");

	finalAngle = m_angle;						// setup in case we have to overshoot and return to this angle
	m_angle = Round(m_angle,1);					// round to 1 decimal place

	// mode 0 = given angle  mode 1 = lookup autoaim angle and verify if valid

	if (m_mode == 1){
		m_angle = Round(GetAutoAimAngle(),1);			// Get auto aiming angle and move the lift there
		SmartDashboard::PutNumber("AutoAim Lift Angle 1", m_angle);
	}

	if ( m_angle >= Robot::liftSys->GetLiftAngle(0)){
		// request angle is above current angle so raise lift
		directionFlag = 1;
		Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedFast);
	}
	else
	{	// angle is below so lower lift
		directionFlag = -1;
		finalAngle = m_angle;
		if (m_angle < 5)
			m_angle = 0;
		else
		{
			m_angle = m_angle -5;	// drive 5 degrees below target and the return due to error in POT
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedFast * -1);
		}
	}
}

// Called repeatedly when this Command is scheduled to run
void LiftToAngleCmd::Execute() {
	currAngle = Robot::liftSys->GetLiftAngle(0);	// mode 0 = get angle by accelerometer, 1=t by encoder, 2=Pot

	if (directionFlag < 0){
		// --------------- Going Down --------------------------
		if ((currAngle - m_angle) > ANGLEFAST){
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedFast * -1);
		}
		else if ((currAngle - m_angle) > ANGLEMED){
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedMed * -1);
		}
		else
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedSlow * -1);
	}
	else{
		// --------------- Going Up --------------------------
		if ((m_angle - currAngle ) > ANGLEFAST){
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedFast);
		}
		else if ((m_angle - currAngle) > ANGLEMED){
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedMed);
		}
		else
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedSlow);
	}
	Robot::liftSys->DisplaySmartdashValues();
	return;
}

// Make this return true when this Command no longer needs to run execute()
bool LiftToAngleCmd::IsFinished() {
	if ((IsTimedOut()) || (m_angle == 999)) return true;	// bad angle or no auto data so get out!
	if (directionFlag < 0){
		// --------------- Going Down --------------------------
		if (Robot::liftSys->GetLowerLmtSw() == true) return true;		// we hit bottom so were done
		if (currAngle <= m_angle) {		// we hit the lower angle we now need to go back up to final angle
			m_angle = finalAngle;
			directionFlag = 1;
			Robot::liftSys->DriveLiftMtr(Robot::liftSys->kLiftSpeedMed);
			return false;
		}
	}
	else{
		if (Robot::liftSys->GetUpperLmtSw() == true) return true;		// we hit top so were done
		if ( currAngle >= m_angle ) return true;						// we have met our target angle so were done
	}
    return false;
}

// Called once after isFinished returns true
void LiftToAngleCmd::End() {
	Robot::liftSys->LiftMtrStop();		// stop motor
	if (m_mode == 1){
		printf("AutoAim Lift Angle End Angle = %4.2f \n", Robot::liftSys->GetLiftAngle(0));	// Logged autoaim angle to console
	}
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void LiftToAngleCmd::Interrupted() {
	End();
}


float LiftToAngleCmd::GetAutoAimAngle(){
	float angle = 999;
	float dist = netTable->GetNumber("TgtDist",0.0);
	float xctr = netTable->GetNumber("TgtCtrX",0.0);
	float yctr = netTable->GetNumber("TgtCtrY",0.0);

	if (netTable->GetNumber("AutoAimFlag",0.0) == false) return 999;
	//if (Robot::liftSys->GetAutoAimFlag() == false) return angle;

	angle = netTable->GetNumber("FinalShootAngle",0.0);	// another way to get data
	netTable->PutNumber("FinalShootAngle",999);	// reset angle so don't repeat same command

	// angle = Robot::liftSys->GetShooterAngle();
	SmartDashboard::PutNumber("AutoAim Lift Angle", angle);
	printf("AutoAim Lift Angle Begin = %4.2f, current Angle = %4.2f \n",angle, Robot::liftSys->GetLiftAngle(0));	// Logged autoaim angle to console
	printf("AutoAim Dist = %4.2f, Xctr=%4.1f, Yctr=%4.1f \n",dist, xctr, yctr);

	if (angle < 20)	return 999;

	return angle;
}


float LiftToAngleCmd::Round(float value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;

	return (round(value * mult) / mult);
}
