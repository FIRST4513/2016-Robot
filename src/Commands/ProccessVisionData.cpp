// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ProccessVisionData.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

ProccessVisionData::ProccessVisionData(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::visionSys.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void ProccessVisionData::Initialize() {

	// ------------- User Initialize Routines ---------------------
	netTable = NetworkTable::GetTable("MyVisionData");
	GetCameraPrefs();							// Defines camera image width, ht. etc.
	GetTestData();
	Robot::lEDRingSys->SetLED(true);			// turn on LED Ring
	testData.VTestFlag = false;					// turn off test data
	processVisionCnt = 5;
}

// Called repeatedly when this Command is scheduled to run
void ProccessVisionData::Execute() {
	if (processVisionCnt < 5){					// only process every 5th time in
		processVisionCnt++;						// because camera rate is 10 fps
		return;
	}
	processVisionCnt = 0;
	GetCurrRobotData();
	GetTargetData();
	ProcessTargetData();
	PostDataToRoborealm();						// Process based on Vision
	PostDataToAutoAim();
	DisplaySmartdashValues();
}

// Make this return true when this Command no longer needs to run execute()
bool ProccessVisionData::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void ProccessVisionData::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void ProccessVisionData::Interrupted() {
	End();
}


// *****************************************************************************
//                                     User Code
// *****************************************************************************


// ****************************************************************************
//                          Main Image Process Routine
// ****************************************************************************
void ProccessVisionData::ProcessTargetData(){
	deltaXangle = 0;
	deltaYangle = 0;

	// ---------------------------------- Step #0 -----------------------------------
	// ---------------------- Do we have a valid target in sight --------------------
	if (validTargetFlag == false) {
		autoAimFlag = false;
		return;
	}

	GAE = currLiftAngle;

	// ---------------------------------- Step #1 -----------------------------------
	// ---------------- Calculate target angles relative to screen Ctr --------------
	//
	//            	( - , - )  |  ( + , - )		X = Neg. if left of Ctr, X = Pos. if Right of Ctr
	//  [Screen		----------------------------
	//	 Angles]	( - , + )  |  ( + , + )		Y = Pos. if Above Ctr,   Y = Neg. if below Ctr.
	//
	// ------------------------------------------------------------------------------

	// ????? THERE SHOULD BE A CORRECTION TO THE COORDINENTS BECAUSE OF LENS ERROR "BARREL IMAGE" IN CAMERA

	targetYangle = ImageAngleConversionFactor * (targetCtrY - imageCtrYpos);	// CED angle
	targetYangle = targetYangle + YCAMERAERRORANGLE;		// Adjustment for miss-aligned camera
	CED = targetYangle;

	targetXangle = ImageAngleConversionFactor * (targetCtrX - imageCtrXpos);	// FCB angle
	targetXangle = targetXangle + XCAMERAERRORANGLE;		// Adjustment for miss-aligned camera
	X_FCB = targetXangle;
	// ---------------------------------- Step #2 -----------------------------------
	// --------- Calculate distance through air to projected target -----------------
	// This distance data allows fine tuning the corrections needed for accurately hitting target
	// Also calculate Ideal SHooting Angle for this distance
	// -------------------------------------------------------------------------------

	EG = 13.5 * sin(CnvrtDegToRad(currLiftAngle));			// CameraRise
	AG = 13.5 * cos(CnvrtDegToRad(currLiftAngle));			// CameraRun
	DF = TgtHt - EG;
	EF = DF / tan(CnvrtDegToRad(GAE + CED));				// Run Camera to tgt

	run = AG + EF;											// (AB) Run to TargetRun from hinge
															// Rise Camera to tgt
	targetDist = sqrt((run*run) + (TgtHt*TgtHt));			// AD Target Diag.

	// convert inches to feet from the camera lens to the wall
	feet = (run - 13.5) / 12;	// ???? SHOULD THIS BE (13.5 * COS(ANGLE)) INSTEAD OF (13.5) ?????
								// ??? angle should be lift angle, or vision horizontal angle ???


	// ***********************************************************************************
	// *** ideal Shooting angle as determined by trial an error at a given distance    ***
	// ***********************************************************************************
		idealShootAngle = (( 0.23 * ( feet*feet )) - ( 5.995 * feet ) + 82.685);	// GAE

	// ***********************************************************************************
	// *** Alternate ideal Shooting angle to position a laser dot in the target        ***
	// ***********************************************************************************
	//idealShootAngle = CnvrtRadToDeg(atan((TgtHt-3.375) / run)) - 3;



	// ---------------------------------- Step #3 -----------------------------------
	// ----------- Calculate Turn Angle (X-Axis) needed to hit center of Target ---------------
	// ----------------------------------------------------------------------------------------

	X_AB = run;													// Run to target from hinge
	X_AD = 13.5 * cos(CnvrtDegToRad(currLiftAngle));
	X_DC = 8.6;
	X_AC = sqrt((X_AD * X_AD) + (X_DC * X_DC));
	X_ACD = CnvrtRadToDeg(atan(X_AD/ X_DC));
	X_ACE = 90 + X_FCB - X_ACD;
	X_AE = X_AC * sin(CnvrtDegToRad(X_ACE));
	X_EAB = CnvrtRadToDeg(acos(X_AE / X_AB));
	X_DAB = X_EAB - (90-X_ACE)-(90-X_ACD);
	turnAngle = X_DAB;

	// ---------------------------------- Step #4 -----------------------------------
	// Add the final delta angles to hit the target to current heading and lift angles
	// -------------------------------------------------------------------------------

	deltaXangle = turnAngle ;
	deltaYangle =  idealShootAngle - currLiftAngle;

	finalshooterHdg = Round((currHdg + deltaXangle), 1);
	finalshooterAngle = Round(idealShootAngle,1);
	autoAimFlag = true;

	// ---------------------------------- Step #8 ------------------------------------
	// --------- Calculate coords for shooter cursor and ball radius -----------------
	// -------------------------------------------------------------------------------

	// ------------Y-Axis Calculations Based on Ideal Shooter Angle ------------------
	EG2 = 13.5 * sin(CnvrtDegToRad(idealShootAngle));			// Camera rise above hinge
	AG2 = 13.5 * cos(CnvrtDegToRad(idealShootAngle));			// Camera Run from hinge
	DF2 = TgtHt-EG2;											// Rise from camera to Tgt
	EF2 = DF2 / tan(CnvrtDegToRad(idealShootAngle + targetYangle)); // Run from camera to Tgt
	FED2 = CnvrtRadToDeg(atan(DF2/EF2));						// Angle camera to target fro level
	CED2 = FED2 - idealShootAngle;								// Angle to Tgt from Img Ctr
	CED2 = CED2 -  YCAMERAERRORANGLE;							// Add in camera alignement error
	BC2 = CED2 / ImageAngleConversionFactor;					// Convert Angle to pixels
	shooterCtrY = imageCtrYpos + BC2;							// Convert to offset from ctr image

	// ----------------------X-Axis Calculations Based on Ideal Shooter Angle ------------------
	X_DG = X_AB - X_AD;											// Run to target from camera
	X_FCG = CnvrtRadToDeg(atan( 8.6 / X_DG));					// Angle for 8.6 camera offset
	X_FG = X_FCG / ImageAngleConversionFactor;					// Convert Angle to pixels
	shooterCtrX = imageCtrXpos + X_FG;							// Convert to offset from ctr image

	// --------------------- Ball Radius at this distance Calculation -----------------------------
	// 5" = ball radius
	shooterRadius = CnvrtRadToDeg(asin( 5 / (targetDist-13.5))) /  ImageAngleConversionFactor;
}

void ProccessVisionData::CalcShooterPosBasedOnDistance(){

}


// *********************************************************************************
//                             Get Various Data Elements
// *********************************************************************************-

// ------------------------ Get Camera System Default Values --------------------
void ProccessVisionData::GetCameraPrefs(){
	imageWidth = Robot::visionSys->GetImageWidth();
	imageHeight =  Robot::visionSys->GetImageHeight();
	imageFOV =Robot::visionSys->GetImageFOV();
	imageCtrXpos = imageWidth / 2;
	imageCtrYpos = imageHeight / 2;
	ImageAngleConversionFactor = imageFOV / imageWidth;
	shooterInchesXoffset = Robot::visionSys->GetImageshooterInchesXoffset();
	shooterInchesYoffset = Robot::visionSys->GetImageshooterInchesYoffset();
	TARGETHT = Robot::visionSys->GetTARGETHT();
}

// ------------------------ Get System Test Default Values --------------------
void ProccessVisionData::GetTestData(){
	testData.VTestFlag = Robot::visionSys->GetTestFlag();
	testData.VTestFlag = false;					// turn off test data
	testData.VTestBall = Robot::visionSys->GetTestBall();
	testData.VTestDist = Robot::visionSys->GetTestDist();
	testData.VTestRun = Robot::visionSys->GetTestRun();
	testData.VTestMaxX = Robot::visionSys->GetTestMaxX();
	testData.VTestMaxY = Robot::visionSys->GetTestMaxY();
	testData.VTestMinX = Robot::visionSys->GetTestMinX();
	testData.VTestMinY = Robot::visionSys->GetTestMinY();
	testData.VTestAngle = Robot::visionSys->GetTestAngle();
	testData.VTestHdg = Robot::visionSys->GetTestHdg();
}

// -------------------------- Get Target data from Roborealm --------------------
void ProccessVisionData::GetTargetData(){
	targetCtrX = 0;
	targetCtrY = 0;
	validTargetFlag = false;
	// SmartDashboard::PutNumber("Vision Test Flag", testData.VTestFlag);

	if (testData.VTestFlag == true){
		targetXmin = testData.VTestMinX;
		targetYmin = testData.VTestMinY;
		targetXmax = testData.VTestMaxX;
		targetYmax = testData.VTestMaxY;
		validTargetFlag = true;
		targetCtrX = round(((targetXmax - targetXmin) /2) + targetXmin);
		targetCtrY = targetYmax;
		return;
	}

	targetXmin = netTable->GetNumber("MIN_X", 0.0);
	targetYmin = netTable->GetNumber("MIN_Y", 0.0);
	targetXmax = netTable->GetNumber("MAX_X", 0.0);
	targetYmax = netTable->GetNumber("MAX_Y", 0.0);

	if ((targetXmin == 0) || (targetXmax == 0) || (targetYmin == 0) || (targetYmax == 0)) return;
	if ((targetXmax == imageWidth) || (targetYmax == imageHeight)) return;

	validTargetFlag = true;
	targetCtrX = round(((targetXmax - targetXmin) /2) + targetXmin);
	targetCtrY = targetYmax;
}

// ----------------- Get Current Robot Oreintation and Lift Angle ---------------------
void ProccessVisionData::GetCurrRobotData(){
	if (testData.VTestFlag == true){
			currHdg = testData.VTestHdg;
			currLiftAngle = testData.VTestAngle;
	}
	else{
		currHdg = Robot::drivetrain->GetHeading(1);			// Gyro current heading
		currLiftAngle = Robot::liftSys->GetLiftAngle(1);	// Current Lift Angle
	}
}

// *********************************************************************************
//                             Send Data back to RoboRealm
// *********************************************************************************
void ProccessVisionData::PostDataToRoborealm(){
	// ----------------- display mode indicator --------------------
	if (Robot::visionSys->GetDisplayMode() == 0) netTable->PutString("Mode","8-Feet Manual");
	if (Robot::visionSys->GetDisplayMode() == 1) netTable->PutString("Mode","Vision");
	if (Robot::visionSys->GetDisplayMode() == 2) netTable->PutString("Mode","Prox-Distance");
	netTable->PutNumber("DispMode",Robot::visionSys->GetDisplayMode());

	if (Robot::shooterSys->GetRearContactLmtSw() == true)
		netTable->PutNumber("HaveBall",1);					// We have a ball in possession
	else
		netTable->PutNumber("HaveBall",0);					// We Dont have a ball in possession

	if (validTargetFlag == false) {
		netTable->PutNumber("DeltaX",0);
		netTable->PutNumber("DeltaY",0);
		netTable->PutNumber("OnTrgt",0);			       // we are still moving to position
		netTable->PutNumber("AutoAimFlag",0);
		netTable->PutNumber("FinalShootHdg",0);
		netTable->PutNumber("FinalShootAngle",0);
		netTable->PutNumber("TgtDist",0);
		return;
	}

	PostTargetCrosshair(targetCtrX, targetCtrY);
	netTable->PutNumber("TgtDist",(Round(((run-13.5)/12),1)));

	PostShooterCrosshair(shooterCtrX, shooterCtrY, shooterLineLen , targetDist);

	// ------- Delta Angles for arrow indicators ---------------
	if (( abs(deltaXangle) < 1) && ( abs(deltaYangle) <1))
		netTable->PutNumber("OnTrgt",1);				  // we are there good job
	else
		netTable->PutNumber("OnTrgt",0);				  // we are still moving to position

	netTable->PutNumber("DeltaX",deltaXangle);
	netTable->PutNumber("DeltaY",Round(deltaYangle,1));
	netTable->PutNumber("TgtDist",targetDist);
	netTable->PutNumber("TgtCtrX",targetCtrX);
	netTable->PutNumber("TgtCtrY",targetCtrY);

	netTable->PutNumber("AutoAimFlag",autoAimFlag);
	netTable->PutNumber("FinalShootHdg",finalshooterHdg);
	netTable->PutNumber("FinalShootAngle",finalshooterAngle);

}

// --------------------------- Target Crosshair Indicator ----------------------------------------
void ProccessVisionData::PostTargetCrosshair(float targetX, float targetY){

	netTable->PutNumber("TgtValid",1);				// we have a target
	netTable->PutNumber("TgtCtrX",targetX);
	netTable->PutNumber("TgtCtrY",targetY);
}

// --------------------------- Shooter Crosshair Indicator ----------------------------------------
void ProccessVisionData::PostShooterCrosshair(float shooterX, float shooterY, float lineLen, float distance){
	netTable->PutNumber("ShootCtrX",shooterCtrX);
	netTable->PutNumber("ShootCtrY",shooterCtrY);
	netTable->PutNumber("ShootRadius",shooterRadius);

/*
	float halfline = round(lineLen /2);
	shooterHLineX1 = shooterX - halfline;
	shooterHLineY1 = shooterY;
	shooterHLineX2 = shooterX + lineLen;
	shooterHLineY2 = shooterY;
	shooterVLineX1 = shooterX;
	shooterVLineY1 = shooterY - halfline;
	shooterVLineX2 = shooterX;
	shooterVLineY2 = shooterY + lineLen;
	netTable->PutNumber("ShootHLineX1",shooterHLineX1);
	netTable->PutNumber("ShootHLineY1",shooterHLineY1);
	netTable->PutNumber("ShootHLineX2",shooterHLineX2);
	netTable->PutNumber("ShootHLineY2",shooterHLineY2);
	netTable->PutNumber("ShootVLineX1",shooterVLineX1);
	netTable->PutNumber("ShootVLineY1",shooterVLineY1);
	netTable->PutNumber("ShootVLineX2",shooterVLineX2);
	netTable->PutNumber("ShootVLineY2",shooterVLineY2);

	// --------- Adjust 10 inch ball on screen size at this distance --------------
	float temp = CnvrtRadToDeg((atan (5.0 / distance)));			// scale 10inch ball for distance
	shooterRadius =  round((temp / ImageAngleConversionFactor));
	netTable->PutNumber("ShootRadius",shooterRadius);
*/
}

// ----------------------------------------------------------------------
//       Post Data Back to LiftSystem and DriveSystem for AutoAim
// ----------------------------------------------------------------------
void ProccessVisionData::PostDataToAutoAim(){
	Robot::drivetrain->PutShooterAutoAimFlag(autoAimFlag);
	netTable->PutNumber("AutoAimFlag",autoAimFlag);

	if (autoAimFlag == true){
		Robot::drivetrain->PutShooterAutoAimHdg(finalshooterHdg);
		Robot::liftSys->PutShooterAngle(finalshooterAngle);
		netTable->PutNumber("FinalShootHdg",finalshooterHdg);
		netTable->PutNumber("FinalShootAngle",finalshooterAngle);
	}
	else
	{
		Robot::drivetrain->PutShooterAutoAimHdg(0);
		Robot::liftSys->PutShooterAngle(0);
		netTable->PutNumber("FinalShootHdg",0);
		netTable->PutNumber("FinalShootAngle",0);
	}
}

// *********************************************************************************
//                             Various Conversion Routines
// *********************************************************************************
float ProccessVisionData::ConvertImageAngleToPixelCnt(float angle, float ctr){
	float pos=0;
	pos = (angle / ImageAngleConversionFactor) + ctr;
	return (Round(pos, 0));
}

float ProccessVisionData::ConvertImagePosToAngle(float pos, float ctr ){
	float angle;
	angle = ( pos - ctr ) * ImageAngleConversionFactor;
	return (angle);
}

float ProccessVisionData::CnvrtDegToRad(float degree){
	float rad = degree * DEGREETORADIANCONST;
	return rad;
}

float ProccessVisionData::CnvrtRadToDeg(float radian){
	float deg = RADIANSTODEGREECONST * radian;
	return deg;
}

float ProccessVisionData::Round(float value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;

	return (round(value * mult) / mult);
}

// *********************************************************************************
//                             SmartDashboard Update
// *********************************************************************************-
void ProccessVisionData::DisplaySmartdashValues(){
	//DisplaySmartdashSimple();

	SmartDashboard::PutNumber("Target Xmin", targetXmin);
	SmartDashboard::PutNumber("Target Xmax", targetXmax);
	SmartDashboard::PutNumber("Target Ymin", targetYmin);
	SmartDashboard::PutNumber("Target Ymax", targetYmax);
	SmartDashboard::PutNumber("Target CtrX", targetCtrX);
	SmartDashboard::PutNumber("Target CtrY", targetCtrY);

	SmartDashboard::PutNumber("Vision Step #1X", targetXangle);
	SmartDashboard::PutNumber("Vision Step #1Y", targetYangle);

	SmartDashboard::PutNumber("EG", EG);					//CameraRise
	SmartDashboard::PutNumber("AG",AG);						// CameraRun
	SmartDashboard::PutNumber("DF",DF);
	SmartDashboard::PutNumber("EF",EF);						// Run Camera to tgt



//	SmartDashboard::PutNumber("Vision Step #2Hdg", adjShooterHdg);
//	SmartDashboard::PutNumber("Vision Step #2Ang", adjShooterAngle);

	SmartDashboard::PutNumber("Vision Step #3run", run);
	SmartDashboard::PutNumber("Vision Step #3Dist", targetDist);
//	SmartDashboard::PutNumber("Target Distance", targetDist);

	SmartDashboard::PutNumber("Vision Step #4 tempAngleA", tempAngleA);
	SmartDashboard::PutNumber("Vision Step #4 tempSideB", tempSideB);
	SmartDashboard::PutNumber("Vision Step #4 tempAngleC", tempAngleC);
	SmartDashboard::PutNumber("Vision Step #4 turnAngle", turnAngle);
	SmartDashboard::PutNumber("Vision Step #4B Ideal Ang", idealShootAngle);


	SmartDashboard::PutNumber("Vision Step #6X", deltaXangle);
	SmartDashboard::PutNumber("Vision Step #6Y", deltaYangle);
	SmartDashboard::PutNumber("Vision Step #7Hdg", finalshooterHdg);
	SmartDashboard::PutNumber("Vision Step #7Ang", finalshooterAngle);

//	SmartDashboard::PutNumber("Vision Step #4B X Ang", shooterCtrXoffsetAngle);
//	SmartDashboard::PutNumber("Vision Step #4B Y Ang", shooterCtrYoffsetAngle);
//	SmartDashboard::PutNumber("Vision Step #5X", shooterCtrX);
//	SmartDashboard::PutNumber("Vision Step #5Y", shooterCtrY);

//	SmartDashboard::PutNumber("Vision 4 Angle", currLiftAngle);
//	SmartDashboard::PutNumber("Vision 4 Hdg", currHdg);
//	SmartDashboard::PutNumber("ShooterXoffsetAngle", shooterCtrXoffsetAngle);
//	SmartDashboard::PutNumber("ShooterYoffsetAngle", shooterCtrYoffsetAngle);
}

void ProccessVisionData::DisplaySmartdashSimple(){

}
